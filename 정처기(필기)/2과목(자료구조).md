# **소프트웨어 개발**

## **자료구조** ⭐️⭐️

자료구조의 분류

선형구조 (Linear Structure) - 순서가있는

- 배열(Array)
- 스택(Stack)
- 큐(Queue)
- 데크(Deque)
- 선형 리스트(Linear List) = 연속 리스트(순차적), 연결 리스트(순차적이지 않음)

비선형 구조 (Non-Linear Structure) - 순서가 없는

- 트리(Tree)
- 그래프(Graph)

ex)선형구조 → 테이프의 5번 트랙을 듣고싶다면 1번트랙부터 빨리감기를 해야만한다.

비선형 구조 → 유튜브에서는 몇분대 영상을 보고싶으면 그냥 클릭하면된다.

배열 (Array)

- 정적인 자료 구조로 기억장소의 추가가 어렵고 메모리의 낭비가 발생
- 첨자를 이용(index를 뜻함)
- 반복적인 데이터 처리 작업에 적합한 구조
- 데이터 마다 동일한 이름의 변수를 사용해 처리가 간편하다

스택(Stack)

- 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이뤄지는 자료구조
- 후입 선출(LIFO; Last IN First Out)방식

큐(Queue)

- 리스트의 한쪽에서는 삽입작업, 다른 한쪽에서는 삭제 작업이 이뤄지는 자료구조
- 선입선출(FIFO;First In First Out)방식
- 시작과 끝을 표시하는 두개의 포인터가 있다.
- 운영체제의 작업 스케줄링에 사용한다.

데크(Deque)

- 리스트의 양쪽 끝에서 삽입과 삭제작업을 할 수 있는 자료구조

선형 리스트 (Linear List)

- 연속 리스트(Contiguous List)

  - 배열과 같이 연속되는 기억장소에 저장되는 자료구조
  - 기억장소를 연속적으로 배정받아, 기억장소 이용 효울은 밀도가 1로서 가장 좋다.
  - 중간에 데이터를 삽입하기 위해 연속된 빈 공간이 있어야한다.
  - 삽입, 삭제 시 자료의 이동이 필요하다.

- 연결 리스트(Linked List)

  - 자료들을 반드시 연속적으로 배열시키지 않고 임의의 기억공간을 기억 시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용해 서로 연결 시킨 자료구조
  - 노드의 삽입, 삭제 작업이 용이
  - 기억 공간이 연속적으로 놓여 있지 않아도 저장 가능
  - 연결을 위한 포인터가 필요하기 때문에 순차 리스트에 비해 기억 공간의 효율이 좋지않다.
  - 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느림
  - 중간 노드 연결이 끊어지면 그다음 노드를 찾기 힘들다.

그래프 (Graph)

방향 그래프

- 정점을 연결하는 선에 방향이 있는 그래프
- n개의 정점으로 구성된 방향 그래프의 최대 간선 수 = n(n-1)

무방향 그래프

- 정점을 연결하는 선에 방향이 없는 그래프
- n개의 정점으로 구성된 무방향 그래프의 최대 간선 수 = n(n-1)/2

---

### `트리(Tree)`

트리(Tree) 중요 !

- 정점(Node,노드)와 선분(Branch,가지)를 이용해 사이클을 이루지 않도록 구성한 그래프의 특수한 형태
- 노드(Node):트리의 기본 요소, 자료 항목과 다른항목에 대한 가지(Branch)를 합친것
- 근 노드(Root Node): 트리의 맨위에 있는 노드
- 디그리(Degree,차수):각 노드에서 뻗어나온 가지의 수
- 단말 노드(Teminal Node): 자식이 하나도 없는 노드, 디그리가 0인노드
- 자식 노드(Son Node): 어떤 노드에 연결된 다음 레벨의 노드들
- 부모 노드(Parent Node): 어떤 노드에 연결된 이전 레벨의 노드들
- 형제 노드(Brother Node, Sibling): 동일한 부모를 갖는 노드들
- 트리의 디그리: 노들들의 디그리 중에서 가장 많은 수

- 행위패턴 - 상호작용이나 책임 분배에 대한 부분을 정의하고 결합도는 최소화하는것이 목표

이진트리

- 차수가 2개 이하인 노드들로만 구성되어있는 트리
  ![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b6bcb1e5-0bd1-4d67-b194-798c343b71dc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-02-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.47.51.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220217%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220217T022125Z&X-Amz-Expires=86400&X-Amz-Signature=19b1aff545082d121c79628dbdfb704a4508a6bc9b6afbbd212c94dbc090b637&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-02-15%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25209.47.51.png%22&x-id=GetObject)

트리의 운행법

- 트리를 구성하는 각 노드들을 찾아가는 방법을 운행법(Traversal)이라고한다.
- 이진 트리를 운행하는 방법은 산술식의 표기법과 연관성을 갖는다
- 이진트리 운행법은 3가지가있다.

preorder 운행 : Root → Left → Right 순으로 운행한다. A,B,C

Inorder 운행 : Left → Root → Right 순으로 운행한다. B,A,C

Postorder 운행 : Left → Right → Root순으로 운행한다. B,C,A

- 어떤 운행법이든 무조건 left 먼저 나간다.

수식의 표기법

이진 트리로 만들어진 수식을 인오더, 프리오더, 포스트오더로 운행하면 각각

중위(Infix),전위(Prefix),후위(Postfix)표기법이 된다.

전위 표기법(Prefix): 연산자 → lefr → right, +AB

중위 표기법(InFix): Left →연산자 → Right, A+B

후위 표기법(PostFix) : Left → Right → 연산자, AB+

Infix 표기를 Postfix나 Prefix로 바꾸기

Postfix나 프리 픽스는 스택을 이용하여 처리하므로 Infix는 둘중 하나로 바꾸어서 처리한다.

```c
예제

X = A / B * (C + D) + E

1. 우선순위를 정하기
2.  pre
    1. 연산자, L, R
    2. +CD, /AB,
    3. */AB+CD
    4. +*/AB+CDE
    5. =X+*/AB+CDE
    6. 우선순위를 정해서 그안에서의 연산자, L,R을 해야한다.
3. Post
    1. LR연산자
    2. 똑같이 연산자를 뒤로


Postfix나 Prefix로 표기된 수식을 Infix로 바꾸기

예 ) ABC-/DEF+*+         (Postfix)

post는 앞에서부터 연산자를 가운데 에 넣으면된다.

prefix

똑같이 앞의 연산자를 가운데로 넣는다.

Tip ⇒ 우선순위를 할때 괄호를 만들면서 하면 더 보기 편하다.

```

---

## `정렬(Sort)`

삽입 정렬(Insertion Sort)

- 삽입 정렬은 가장 간단한 정렬 방식으로, 이미 순서화 된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입 시켜 정렬하는 방식
- 평균과 최악 모두 수행시간 복잡도는 O(n2^)이다.

```
예제 8,5,6,2,4를 삽입정렬로 정렬하시오

1. 첫번째 값은 비교대상이없으니 두번째값부터 첫번째와비교
2. 세번째값을 첫번째와 두번째랑 비교
3. 첫번째비교하여 한번 값을 바꾸는것을 1회전, 2회전 이라고한다.
```

선택정렬 (Selection Sort)

- 선택 정렬은 n개의 레코드 중에서 최소 값을 찾아 첫번째 레코드 위치에 놓고, 나머지(n-1)개 중에서 다시 최소값을 찾아 두번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식
- 평균과 최악 모두 수행시간 복잡도는 O(n2^)이다.

```
예제 8,5,6,2,4를 선택정렬로 정렬하시오

1. 8을 기준으로 하나씩 다 비교해서 최소값을 찾고 8의 자리로가져옴
2. 2,8,6,5,4
3. 바꾸는것을 하나씩 다바꿔주고 마지막까지 바꾸고나서의 값이 1회전결과
4. 선택정렬 첫번째인덱스을 선택하고 그 첫번째인덱스를 기준으로 n-1만큼 비교
5. 2,6,8,5,4 → 2,5,8,6,4 → 2,4,8,6,5
```

버블정렬 (Bubble sort)

- 버블 정렬은 주어진 파일에서 인접한 두개의 키 값을 비교하여 그 크기에 따라 레코드 위츠를 서로 교환하는 정렬방식
- 평균과 최악 모두 수행 시간 복잡도는 O(n2^)이다

```
예제 8,5,6,2,4를 버블정렬로 정렬하시오

1. 인접한 수가 비교를하느것이다
2. 5 8 6 2 4 → 56824 → 56284 → 56248
```

쉘 정렬 (Shell Sort)

- 쉘 정렬은 입력 파일을 어떤 `매개변수`의 값으로 서브파일을 구성하고, 각 서브파일을 Insertion(삽입) 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬방식
- `삽입 정렬을 확장한 개념`
- 평균 수행시간 복잡도는 O(n1.5^)이고, 최악의 수행 시간 복잡도는 O(n2^)이다

퀵 정렬(Quick Sort)

- 퀵 정렬은 `키를 기준으로 작은 값은 왼쪽 큰값은 오른쪽 `서브 파일에 분해시키는 과정을 반복하는 정렬방식이다.
- 레코드의 많은 자료이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다
- 평균 수행시간 복잡도는 O(nlof2n)이고 최악의 수행복잡도는 O(n2^)이다.

힙정렬(Heap Sort)

- 힙정렬은 `전이진 트리`를 이용한 정렬방식
- 구성된 전이진트리를 Heap Tree로 변환하여 정렬한다.
- 평균과 최악 모두 복잡도는 O(nlog2n)이다.

2-Way 합병 정렬 (Merge Sort)

- 2-Way 합병 정렬은 `이미 정렬되어 있는 두개의 파일을 한개의 파일로 합병하는 정렬방식`
- 평균과 최악 모두 시간복잡도는 O(nlog2n)이다.

기수 정렬(Radix Sort) = Bucket Sort

- 기수 정렬은 `Queue(큐)를 이용하여 자릿수(Digit)별`로 정렬하는 방식
- 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다.
- ex) 트럼프 카드 → 숫자를 먼저 오름차순으로 정렬한뒤, 문자 별로 정렬한다.
- 평균과 최악 모두 시간 복잡도는 O(dn)이다
