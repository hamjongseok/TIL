# **소프트웨어 개발**

## **데이터베이스 개요** ⭐️⭐️

`데이터베이스(Database)`

- 공용데이터 (Shared Data): 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료
- 통합된 데이터(Interated Data): 자료의 중복을 최대로 배제한 데이터의 모임
- 운영 데이터(Operational Data): 고유한 업무를 수행하는데 없어서는 안 될 자료
- 저장된 데이터(Stored Data): 컴퓨터가 접근 할 수 있는 저장 매체에 저장된 자료

## `공통운저`

---

`DBMS(Database Management System; 데이터베이스 관리 시스템)`

- 사용자와 데이터 베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어
- 최대 장점, 데이터의 독립성 보장
- 필수기능 3가지
- `정의`(Defintition), `조작`(Manipulation), `제어`(Control)
- 정의 기능 : 데이터베이스에 저장될 데이터의 타입과 구조에 대한 정의, 이용방식, 제약 조건등을 명시하는 기능 → DDL
- 조작 기능 : 사용자와 데이터 베이스 사이의 인터페이스 수단을 제공하는 기능 → DML
- 제어 기능 : 무결성, 보안, 권한, 병행 제어 → DCL

---

### `데이터 입출력`

SQL(Structured Query Language)

- 1974년 IBM연구소에서 개발한 SEQUEL에서 유래함
- 관계 대수와 관계 해석을 기초로 한 혼합 데이터 언어

데이터 정의어(DDL; Data Define Language)

- DOMAIN(도메인), SCHEMA(스키마), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 정의하거나 변경 또는 삭제 할 때 사용하는 언어

#도스테뷰인

데이터 조작어(DML; Data Manipulation Language)

- SELECT(검색), INSERT(삽입), UPDATE(갱신), DELETE(삭제)로 저장된 데이터를 실질적으로 처리하는 데 사용하는 언어

데이터 제어어(DCL; Data Control Language)

- 데이터의 무결성, 보안, 회복, 병행제어 등을 정의하는 데 사용되는 언어

데이터 접속(Data Mapping)

- 소프트웨어의 기능 구현을 위해 프로그래밍 코드와 데이터 베이스의 데이터를 연결(Mapping)하는 것을 말한다.
- SQL Mapping
  - 프로그래밍 코드 내 SQL을 직접 입력해 DBMS의 데이터에 접속하는 기술
  - #JDBC, ODBC, MyBatis
- ORM(Object-Relational Mapping)
  - 객체(Object)와 관계형 데이터 베이스(RDB)의 데이터를 연결(Mapping)하는 기술
  - #JPA, Hibernate, Django

트랜잭션(Transaction)

- 데이터베이스의 상태를 변환 시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 한꺼번에 모두 수행되어야 할 일련의 연산들
- COMMIT
  - 트랜잭션 처리가 정상적으로 종료되어 수행한 변경 내용을 DB에 반영하는 명령어
- ROLLBACK
  - 트랜잭션 처리가 비정상으로 종료되어 DB의 일관성이 깨졌을때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산
- SAVEPOINT(=CHECKPOINT)

  - 트랜잭션 내에서 ROLLBACK할 위치인 저장점을 지정하는 명령어, 여러개의 SAVEPOINT 지정 가능

  ![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/501fcb1f-cd8b-4a97-8fb6-5136a4cb2adb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-02-18_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.34.19.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220218%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220218T063646Z&X-Amz-Expires=86400&X-Amz-Signature=7391bd62d95a0c9ca645d0620e7968a0c4168c33f2430e91e45e54ba7ef32585&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202022-02-18%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%25203.34.19.png%22&x-id=GetObject)

---

## `정렬(Sort)`

삽입 정렬(Insertion Sort)

- 삽입 정렬은 가장 간단한 정렬 방식으로, 이미 순서화 된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입 시켜 정렬하는 방식
- 평균과 최악 모두 수행시간 복잡도는 O(n2^)이다.

```
예제 8,5,6,2,4를 삽입정렬로 정렬하시오

1. 첫번째 값은 비교대상이없으니 두번째값부터 첫번째와비교
2. 세번째값을 첫번째와 두번째랑 비교
3. 첫번째비교하여 한번 값을 바꾸는것을 1회전, 2회전 이라고한다.
```

선택정렬 (Selection Sort)

- 선택 정렬은 n개의 레코드 중에서 최소 값을 찾아 첫번째 레코드 위치에 놓고, 나머지(n-1)개 중에서 다시 최소값을 찾아 두번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식
- 평균과 최악 모두 수행시간 복잡도는 O(n2^)이다.

```
예제 8,5,6,2,4를 선택정렬로 정렬하시오

1. 8을 기준으로 하나씩 다 비교해서 최소값을 찾고 8의 자리로가져옴
2. 2,8,6,5,4
3. 바꾸는것을 하나씩 다바꿔주고 마지막까지 바꾸고나서의 값이 1회전결과
4. 선택정렬 첫번째인덱스을 선택하고 그 첫번째인덱스를 기준으로 n-1만큼 비교
5. 2,6,8,5,4 → 2,5,8,6,4 → 2,4,8,6,5
```

버블정렬 (Bubble sort)

- 버블 정렬은 주어진 파일에서 인접한 두개의 키 값을 비교하여 그 크기에 따라 레코드 위츠를 서로 교환하는 정렬방식
- 평균과 최악 모두 수행 시간 복잡도는 O(n2^)이다

```
예제 8,5,6,2,4를 버블정렬로 정렬하시오

1. 인접한 수가 비교를하느것이다
2. 5 8 6 2 4 → 56824 → 56284 → 56248
```

쉘 정렬 (Shell Sort)

- 쉘 정렬은 입력 파일을 어떤 `매개변수`의 값으로 서브파일을 구성하고, 각 서브파일을 Insertion(삽입) 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬방식
- `삽입 정렬을 확장한 개념`
- 평균 수행시간 복잡도는 O(n1.5^)이고, 최악의 수행 시간 복잡도는 O(n2^)이다

퀵 정렬(Quick Sort)

- 퀵 정렬은 `키를 기준으로 작은 값은 왼쪽 큰값은 오른쪽 `서브 파일에 분해시키는 과정을 반복하는 정렬방식이다.
- 레코드의 많은 자료이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다
- 평균 수행시간 복잡도는 O(nlof2n)이고 최악의 수행복잡도는 O(n2^)이다.

힙정렬(Heap Sort)

- 힙정렬은 `전이진 트리`를 이용한 정렬방식
- 구성된 전이진트리를 Heap Tree로 변환하여 정렬한다.
- 평균과 최악 모두 복잡도는 O(nlog2n)이다.

2-Way 합병 정렬 (Merge Sort)

- 2-Way 합병 정렬은 `이미 정렬되어 있는 두개의 파일을 한개의 파일로 합병하는 정렬방식`
- 평균과 최악 모두 시간복잡도는 O(nlog2n)이다.

기수 정렬(Radix Sort) = Bucket Sort

- 기수 정렬은 `Queue(큐)를 이용하여 자릿수(Digit)별`로 정렬하는 방식
- 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다.
- ex) 트럼프 카드 → 숫자를 먼저 오름차순으로 정렬한뒤, 문자 별로 정렬한다.
- 평균과 최악 모두 시간 복잡도는 O(dn)이다
